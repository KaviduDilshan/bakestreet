import{createFilter as t}from"@rollup/pluginutils";import e from"fs";import n from"fs/promises";import i from"os";import o from"path";import{createPack as s}from"tar-mini";import r from"util";import a from"zlib";function c(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t}var u,l={exports:{}};function p(){if(u)return l.exports;u=1;let t,e,n,{defineProperty:i,setPrototypeOf:o,create:s,keys:r}=Object,a="",{round:c,max:p}=Math,f=t=>{let e=/([a-f\d]{3,6})/i.exec(t)?.[1],n=e?.length,i=parseInt(6^n?3^n?"0":e[0]+e[0]+e[1]+e[1]+e[2]+e[2]:e,16);return[i>>16&255,i>>8&255,255&i]},d=(t,e,n)=>t^e||e^n?16+36*c(t/51)+6*c(e/51)+c(n/51):8>t?16:t>248?231:c(24*(t-8)/247)+232,h=t=>{let e,n,i,o,s;return 8>t?30+t:16>t?t-8+90:(232>t?(s=(t-=16)%36,e=(t/36|0)/5,n=(s/6|0)/5,i=s%6/5):e=n=i=(10*(t-232)+8)/255,o=2*p(e,n,i),o?30+(c(i)<<2|c(n)<<1|c(e))+(2^o?0:60):30)},m=(()=>{let n=t=>s.some((e=>t.test(e))),i=globalThis,o=i.process??{},s=o.argv??[],a=o.env??{},c=-1;try{t=","+r(a).join(",")}catch(t){a={},c=0}let u="FORCE_COLOR",l={false:0,0:0,1:1,2:2,3:3}[a[u]]??-1,p=u in a&&l||n(/^--color=?(true|always)?$/);return p&&(c=l),~c||(c=((n,i,o)=>(e=n.TERM,{"24bit":3,truecolor:3,ansi256:2,ansi:1}[n.COLORTERM]||(n.CI?/,GITHUB/.test(t)?3:1:i&&"dumb"!==e?o?3:/-256/.test(e)?2:1:0)))(a,!!a.PM2_HOME||a.NEXT_RUNTIME?.includes("edge")||!!o.stdout?.isTTY,"win32"===o.platform)),!l||a.NO_COLOR||n(/^--(no-color|color=(false|never))$/)?0:i.window?.chrome||p&&!c?3:c})(),g={open:a,close:a},w=39,y=49,b={},O=({p:t},{open:e,close:i})=>{let s=(t,...n)=>{if(!t){if(e&&e===i)return e;if((t??a)===a)return a}let o,r=t.raw?String.raw({raw:t},...n):a+t,c=s.p,u=c.o,l=c.c;if(r.includes(""))for(;c;c=c.p){let{open:t,close:e}=c,n=e.length,i=a,s=0;if(n)for(;~(o=r.indexOf(e,s));s=o+n)i+=r.slice(s,o)+t;r=i+r.slice(s)}return u+(r.includes("\n")?r.replace(/(\r?\n)/g,l+"$1"+u):r)+l},r=e,c=i;return t&&(r=t.o+e,c=i+t.c),o(s,n),s.p={open:e,close:i,o:r,c:c,p:t},s.open=r,s.close=c,s};const v=function(t=m){let e={Ansis:v,isSupported:()=>r,strip:t=>t.replace(/[Â›][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g,a),extend(t){for(let e in t){let n=t[e],o=(typeof n)[0],s="s"===o?P(...f(n)):n;b[e]="f"===o?{get(){return(...t)=>O(this,n(...t))}}:{get(){let t=O(this,s);return i(this,e,{value:t}),t}}}return n=s({},b),o(e,n),e}},r=t>0,c=(t,e)=>r?{open:`[${t}m`,close:`[${e}m`}:g,u=t=>e=>t(...f(e)),l=(t,e)=>(n,i,o)=>c(`${t}8;2;${n};${i};${o}`,e),p=(t,e)=>(n,i,o)=>c(((t,e,n)=>h(d(t,e,n)))(n,i,o)+t,e),x=t=>(e,n,i)=>t(d(e,n,i)),P=l(3,w),E=l(4,y),R=t=>c("38;5;"+t,w),j=t=>c("48;5;"+t,y);2===t?(P=x(R),E=x(j)):1===t&&(P=p(0,w),E=p(10,y),R=t=>c(h(t),w),j=t=>c(h(t)+10,y));let S,T={fg:R,bg:j,rgb:P,bgRgb:E,hex:u(P),bgHex:u(E),visible:g,reset:c(0,0),bold:c(1,22),dim:c(2,22),italic:c(3,23),underline:c(4,24),inverse:c(7,27),hidden:c(8,28),strikethrough:c(9,29)},z="Bright";return"black,red,green,yellow,blue,magenta,cyan,white,gray".split(",").map(((t,e)=>{S="bg"+t[0].toUpperCase()+t.slice(1),8>e?(T[t+z]=c(90+e,w),T[S+z]=c(100+e,y)):e=60,T[t]=c(30+e,w),T[S]=c(40+e,y)})),e.extend(T)},x=new v;return l.exports=x,x.default=x,l.exports}var f=c(p());function d(t){return t.length}function h(t,e){const n="function"==typeof e?e(t):e,{dir:i,base:s}=o.parse(t),r=i?i+"/":"";return n.replace(/\[path\]/,r).replace(/\[base\]/,s)}function m(t){return/^\\\\\?\\/.test(t)?t:t.replace(/\\/g,"/")}const g=new TextEncoder;function w(t){return"string"==typeof t?g.encode(t):t}function y(){}function b(t){const e=t in a?t:"gzip";return{algorithm:r.promisify(a[e])}}async function O(t,e,n){try{return await e(t,n)}catch(t){return Promise.reject(t)}}const v={gzip:{level:a.constants.Z_BEST_COMPRESSION},brotliCompress:{params:{[a.constants.BROTLI_PARAM_QUALITY]:a.constants.BROTLI_MAX_QUALITY}},deflate:{level:a.constants.Z_BEST_COMPRESSION},deflateRaw:{level:a.constants.Z_BEST_COMPRESSION}};class x{constructor(t){this.maxConcurrent=t,this.queue=[],this.errors=[],this.running=0}enqueue(t){this.queue.push(t),this.run()}async run(){for(;this.running<this.maxConcurrent&&this.queue.length;){const t=this.queue.shift();this.running++;try{await t()}catch(t){this.errors.push(t)}finally{this.running--,this.run()}}}async wait(){for(;this.running;)await new Promise((t=>setTimeout(t,0)));if(d(this.errors))throw new AggregateError(this.errors,"task failed")}}function P(t){return new x(t)}const E="vite-plugin-compression",R=(()=>{const t=i.cpus()||{length:1};return 1===t.length?10:Math.max(1,t.length-1)})();function j(t){const e=new Set,n=(t,e)=>m(o.resolve(t,e));if(t.build.rollupOptions?.output){(Array.isArray(t.build.rollupOptions.output)?t.build.rollupOptions.output:[t.build.rollupOptions.output]).forEach((i=>{("object"!=typeof i||d(Object.keys(i)))&&e.add(n(t.root,i.dir||t.build.outDir))}))}else e.add(n(t.root,t.build.outDir));return e}async function S(t,i){const s=!("copyPublicDir"in t.build)||t.build.copyPublicDir;if(t.publicDir&&s&&e.existsSync(t.publicDir)){const e=await async function(t){const e=await Promise.all((await n.readdir(t)).map((e=>o.join(t,e))));let i=0;const s=[];for(;i!==d(e);){const t=e[i],r=await n.stat(t);if(r.isDirectory()){const i=await n.readdir(t);e.push(...i.map((e=>o.join(t,e))))}r.isFile()&&s.push(t),i++}return s}(t.publicDir),s=o.join(t.root,o.relative(t.root,t.publicDir));e.forEach((t=>{const e=m(o.relative(s,t));i(e,t)}))}}function T(t={}){const{dest:i,gz:r=!1}=t,c=[],u=[];let l=[],p=process.cwd();const f=function(){const t=s(),n=[],i={dests:[],root:"",gz:!1};return{add:e=>{t.add(w(e.content),{filename:e.filename})},setup:t=>{Object.assign(i,t),i.dests.forEach((t=>{const s=m(o.resolve(i.root,t+".tar"+(i.gz?".gz":""))),r=m(o.dirname(s));m(i.root)!==r&&e.mkdirSync(r,{recursive:!0});const a=e.createWriteStream(s);n.push(a)}))},done:async()=>{t.done(),await Promise.all(n.map((e=>new Promise(((n,o)=>{e.on("error",o),e.on("finish",n),i.gz?t.receiver.pipe(a.createGzip()).pipe(e):t.receiver.pipe(e)}))))),n.length=0}}}(),d=P(R);let h;return{name:"vite-plugin-tarball",enforce:"post",async configResolved(t){u.push(...j(t)),p=t.root,l=i?[i]:u,h=z.getPluginAPI(t.plugins),h||await S(t,(t=>{c.push(t)})),f.setup({dests:l,root:p,gz:r})},writeBundle(t,e){for(const t in e){const n=e[t];f.add({filename:t,content:"asset"===n.type?n.source:n.code})}},async closeBundle(){h&&await h.done,!c.length&&h&&h.staticOutputs.size&&c.push(...h.staticOutputs);for(const t of u)for(const e of c)d.enqueue((async()=>{const i=o.join(t,e),s=await n.readFile(i);f.add({filename:e,content:s})}));await d.wait(),await f.done()}}}function z(e={}){const{include:i=/\.(html|xml|css|json|js|mjs|svg|yaml|yml|toml)$/,exclude:s,threshold:r=0,algorithm:a="gzip",filename:c,compressionOptions:u,deleteOriginalAssets:l=!1,skipIfLargerOrEqual:p=!0}=e,m=t(i,s),g=[],x=[],{msgs:T,cleanup:z}=function(){const t=[],e=process.stdout.write.bind(process.stdout);return process.stdout.write=function(...n){const[i]=n,o="string"==typeof i?i:i.toString();return o.includes("built in")?(t.push(o),!1):e.apply(this,n)},{cleanup:()=>process.stdout.write=e,msgs:t}}();let _,I=process.cwd();const C={algorithm:"string"==typeof a?b(a).algorithm:a,options:"function"==typeof a?u:Object.assign({},v[a],u),filename:c??("brotliCompress"===a?"[path][base].br":"[path][base].gz")},M=P(R),A=async function(t,e){for(const t in e){if(!m(t))continue;const n=e[t],i=w("asset"===n.type?n.source:n.code),o=d(i);o<r||M.enqueue((async()=>{const n=h(t,C.filename),s=await O(i,C.algorithm,C.options);p&&d(s)>=o||((l||t===n)&&Reflect.deleteProperty(e,t),this.emitFile({type:"asset",fileName:n,source:s}))}))}await M.wait().catch(this.error)},B={resolve:y},D={staticOutputs:new Set,done:new Promise((t=>{B.resolve=t}))},$=new Intl.NumberFormat("en",{maximumFractionDigits:2,minimumFractionDigits:2});return{name:E,apply:"build",enforce:"post",api:D,async configResolved(t){x.push(...j(t)),await S(t,(t=>{g.push(t)}));const e=t.plugins.find((t=>"vite:build-import-analysis"===t.name));if(!e)throw new Error("[vite-plugin-compression] Can't be work in versions lower than vite at 2.0.0");!function(t,e){const n=t.generateBundle;if("object"==typeof n&&n.handler){const t=n.handler;n.handler=async function(...n){await t.apply(this,n),await e.apply(this,n)}}"function"==typeof n&&(t.generateBundle=async function(...t){await n.apply(this,t),await e.apply(this,t)})}(e,A),_=t.logger,I=t.root},async closeBundle(){const t=[],e=async(e,i)=>{const s=o.join(e,i);if(!m(s)&&!D.staticOutputs.has(i))return void D.staticOutputs.add(i);const{size:a}=await n.stat(s);a<r?D.staticOutputs.has(i)||D.staticOutputs.add(i):await(async(e,i,s)=>{const r=await n.readFile(e),a=await O(r,C.algorithm,C.options);if(p&&d(a)>=d(r))return void(D.staticOutputs.has(i)||D.staticOutputs.add(i));const c=h(i,C.filename);D.staticOutputs.has(c)||D.staticOutputs.add(c);const u=o.join(s,c);l&&u!==e&&await n.rm(e,{recursive:!0,force:!0}),await n.writeFile(u,a),t.push({dest:o.relative(I,s)+"/",file:c,size:d(a)})})(s,i,e)};for(const t of x)for(const n of g)M.enqueue((()=>e(t,n)));if(await M.wait().catch((t=>t)),B.resolve(),z(),_){const e=t.reduce(((t,e)=>{const n=e.dest+e.file;return Math.max(t,n.length)}),0);for(const{dest:n,file:o,size:s}of t){const t=o.padEnd(e);_.info(f.dim(n)+f.green(t)+f.bold(f.dim((i=s,`${$.format(i/1e3)} kB`))))}}var i;for(const t of T)console.info(t)}}}function _(t){return t}z.getPluginAPI=t=>t.find((t=>t.name===E))?.api;export{z as compression,z as default,_ as defineCompressionOption,T as tarball};
